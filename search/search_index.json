{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TAREA RA1 - H\u00c9CTOR BL\u00c1ZQUEZ G\u00d3MEZ En esta tarea obligatoria trabajo sobre un c\u00f3digo de python que simula el comportamiento de un lavadero de coches , con el har\u00e9 distintas pruebas, entre ellas: Una ejecuci\u00f3n y depuraci\u00f3n del c\u00f3digo para comprobar fallos de ejecuci\u00f3n. Una ejeuci\u00f3n en un entorno seguro con firejail. Una serie de pruebas unitariarias para comrpobar y corregir unos fallos de ejecucci\u00f3n que est\u00e1n presentes en el c\u00f3digo. Tambi\u00e9n en esta documentaci\u00f3n hay una apartado que es una reflexi\u00f3n personal m\u00eda sobre la seguridad en sistemas operativos y un archivo .ipynb con los dos ficheros de la aplicaci\u00f3n comentados. Go to Ejecuci\u00f3n y Depruraci\u00f3n Sandbox Pruebas unitarias Reflexi\u00f3n personal","title":"Indice"},{"location":"#tarea-ra1-hector-blazquez-gomez","text":"En esta tarea obligatoria trabajo sobre un c\u00f3digo de python que simula el comportamiento de un lavadero de coches , con el har\u00e9 distintas pruebas, entre ellas: Una ejecuci\u00f3n y depuraci\u00f3n del c\u00f3digo para comprobar fallos de ejecuci\u00f3n. Una ejeuci\u00f3n en un entorno seguro con firejail. Una serie de pruebas unitariarias para comrpobar y corregir unos fallos de ejecucci\u00f3n que est\u00e1n presentes en el c\u00f3digo. Tambi\u00e9n en esta documentaci\u00f3n hay una apartado que es una reflexi\u00f3n personal m\u00eda sobre la seguridad en sistemas operativos y un archivo .ipynb con los dos ficheros de la aplicaci\u00f3n comentados.","title":"TAREA RA1 - H\u00c9CTOR BL\u00c1ZQUEZ G\u00d3MEZ"},{"location":"#go-to","text":"Ejecuci\u00f3n y Depruraci\u00f3n Sandbox Pruebas unitarias Reflexi\u00f3n personal","title":"Go to"},{"location":"ejecuccion-y-depuracion/","text":"DEPURACI\u00d3N DEL C\u00d3DIGO En un primer intento voy a tratar de ejecutar el c\u00f3digo de forma normal, simplemente dandole al bot\u00f3n de arriba a la izquierda en VS Code. Como se puede apreciar en la consola de salida, el programa funciona hasta cierto momento en el que este nos avisa de un error entonces lo siguiente que debemos hacer es ejecutar una depuraci\u00f3n del c\u00f3digo , en este caso no necesitamos un breakpoint ya que al dar un error de ejecucci\u00f3n el programa parar\u00e1 en el momento exacto en el que sucede. Para ejecutar una depuraci\u00f3n en VS Code podemos apreciar que hay una pesta\u00f1ita para desplegar al lado del bot\u00f3n de ejecucci\u00f3n , dentro de ese men\u00fa encontraremos la opci\u00f3n de depurar el c\u00f3digo. O tambi\u00e9n en el men\u00fa del lateral izquierdo tendremos un apartado para ejecutar y depurar nuesto c\u00f3digo. Como se puede apreciar , nos salta el mismo error, este dicta que nos falta el parametro encerado al llamar al m\u00e9todo \"ejecutarSimulaci\u00f3n\" , asi que una vez a\u00f1adamos ese parametro en false como especifica el comentario, el programa deber\u00eda funcionar a las mil maravillas.","title":"Ejecuci\u00f3n y depuraci\u00f3n"},{"location":"ejecuccion-y-depuracion/#depuracion-del-codigo","text":"En un primer intento voy a tratar de ejecutar el c\u00f3digo de forma normal, simplemente dandole al bot\u00f3n de arriba a la izquierda en VS Code. Como se puede apreciar en la consola de salida, el programa funciona hasta cierto momento en el que este nos avisa de un error entonces lo siguiente que debemos hacer es ejecutar una depuraci\u00f3n del c\u00f3digo , en este caso no necesitamos un breakpoint ya que al dar un error de ejecucci\u00f3n el programa parar\u00e1 en el momento exacto en el que sucede. Para ejecutar una depuraci\u00f3n en VS Code podemos apreciar que hay una pesta\u00f1ita para desplegar al lado del bot\u00f3n de ejecucci\u00f3n , dentro de ese men\u00fa encontraremos la opci\u00f3n de depurar el c\u00f3digo. O tambi\u00e9n en el men\u00fa del lateral izquierdo tendremos un apartado para ejecutar y depurar nuesto c\u00f3digo. Como se puede apreciar , nos salta el mismo error, este dicta que nos falta el parametro encerado al llamar al m\u00e9todo \"ejecutarSimulaci\u00f3n\" , asi que una vez a\u00f1adamos ese parametro en false como especifica el comentario, el programa deber\u00eda funcionar a las mil maravillas.","title":"DEPURACI\u00d3N DEL C\u00d3DIGO"},{"location":"pruebas/","text":"Pruebas unitarias En este documento mi objetivo es realizar en c\u00f3digo de python algunas pruebas unitarias y comprobar su resultado, el esquema que seguir\u00e9 ser\u00e1 ir una por una explicando la prueba, si da error y luego explicar el c\u00f3digo solucionado con una catura de pantalla. Prueba 1 def test1_estado_inicial_correcto(self): \"\"\"Test 1: Verifica que el estado inicial es Inactivo y con 0 ingresos.\"\"\" self.assertEqual(self.lavadero.fase, Lavadero.FASE_INACTIVO) self.assertEqual(self.lavadero.ingresos, 0.0) self.assertFalse(self.lavadero.ocupado) Aqu\u00ed comprueba que los valores base son los correctos utilizando `assert. Como se puede apreciar en la imagen el test1 se pasa sin problema. Prueba 2 def test2_excepcion_encerado_sin_secado(self): \"\"\"Test 2: Comprueba que encerar sin secado a mano lanza ValueError.\"\"\" # _hacer_lavado: (Prelavado: False, Secado a mano: False, Encerado: True) with self.assertRaises(ValueError): self.lavadero.hacerLavado(False, False, True) En este test se comprueba que cuando se va a comenzar la fase de encerar sin haber secado a mano el programa lance un ValueError (En la pr\u00e1ctica especifica otro tipo de excepci\u00f3n IllegalArgumentException pero esta al parecer no es un error de python y el que se utilza en python es ValueError), esto se comrpueba con la l\u00ednea de assertRaises la cual comprobar\u00e1 si la excepci\u00f3n es la que esperamos. Como se puede ver en la imagen , nos devuelve la excepci\u00f3n que queremos por lo tanto este test tambi\u00e9n lo pasa. Prueba 3 def test3_excepcion_lavado_ocupado(self): \"\"\"Test 3: Verifica que intentar lavar cuando el lavadero est\u00e1 ocupado lanza IllegalStateException.\"\"\" self.lavadero.hacerLavado(True, False, False) # Inicia un lavado with self.assertRaises(IllegalStateException): self.lavadero.hacerLavado(False, True, False) # Intenta iniciar otro lavado Como en el anterior buscamos que nos salga el error que especificamos (IllegalStateException). \u00a1Vaya! Parece que esta vez no ha pasado el test nuestro c\u00f3digo, si analizamos el error vemos que nos levanta otra excepci\u00f3n , por suerte eso tiene facil soluci\u00f3n, en el m\u00e9todo de hacerLavado dentro del primer if debemos cambiar la excepci\u00f3n que levanta a IllegalStateException e importarla. Una vez arreglado y guardado nuestro c\u00f3digo, comprobamos que esta vez pasa el test. Prueba 4 def test4_prelavadoamano_ingresos_correctos(self): \"\"\"Test 4: Verifica que el prelavado a mano a\u00f1ade 6.5 a los ingresos.\"\"\" self.lavadero.hacerLavado(True, False, False) self.lavadero._cobrar() self.assertEqual(self.lavadero.ingresos, 6.5) Este test hace una prueba de un lavado con un prelavado a mano y luego al cobrar verifica que el resultado sea 6.5. Como se puede apreciar en la imagen , se ha pasado el test a la primera y si nos fijamos en el c\u00f3digo podemos ver que el lavado tiene un precio base de 5 y el prelavado a mano a\u00f1ade 1.5, acabamos de comprobar que nuestro test funciona y que nuestro c\u00f3digo lo ha pasado. Prueba 5 def test5_secadoamano_ingresos_correctos(self): \"\"\"Test 5: Verifica que el secado a mano a\u00f1ade 6.0 a los ingresos.\"\"\" self.lavadero.hacerLavado(False, True, False) self.lavadero._cobrar() self.assertEqual(self.lavadero.ingresos, 6.0) La l\u00f3gica es la misma que con el test 4 solo que el secado a mano deber\u00eda dar como resultado 6. Falla el test, en la variable se suman 20 ctms m\u00e1s de los que se deber\u00edan as\u00ed que cambio el valor de sumar a 1 en vez de 1.20. Y comprobamos que pasa el test. Prueba 6 def test6_secadoamano_y_encerado_ingresos_correctos(self): \"\"\"Test 6: Verifica que el secado a mano y encerado a\u00f1aden 7.2 a los ingresos.\"\"\" self.lavadero.hacerLavado(False, True, True) self.lavadero._cobrar() self.assertEqual(self.lavadero.ingresos, 7.2) Lo mismo pero juntando secado a mano y encerado, los ingresos deber\u00edan ser 7.2 Nos da error ya que cuenta 20 ctms de menos, se arregla cambiando el valor de el encerado y subiendole 0.20. Comprobaci\u00f3n : Prueba 7 def test7_prelavadoamano_y_secadoamano_ingresos_correctos(self): \"\"\"Test 7: Verifica que el prelavado a mano y secado a mano a\u00f1aden 7.5 a los ingresos.\"\"\" self.lavadero.hacerLavado(True, True, False) self.lavadero._cobrar() self.assertEqual(self.lavadero.ingresos, 7.5) El resultado de esta prueba deber\u00e1 ser 7.5 ya que junta prelavado a mano y secado a mano. Da el resultado correcto ya que con los test anteriores he cambiado los valores para que cuadren. Prueba 8 def test8_todas_opciones_ingresos_correctos(self): \"\"\"Test 8: Verifica que todas las opciones a\u00f1aden 8.7 a los ingresos.\"\"\" self.lavadero.hacerLavado(True, True, True) self.lavadero._cobrar() self.assertEqual(self.lavadero.ingresos, 8.7) Este test comprueba que teniendo todas las opciones de lavado activadas de 8.70 euros de ingresos. Como en el test anterior este da la cantidad correcta porque hemos modificado las variables anteriormente. Prueba 9 def test9_avanzarfases_sin_extras(self): \"\"\"Test 9: Verifica la secuencia de fases: 0,1,3,4,5,6,0.\"\"\" # Para alcanzar la fase 6 (secado autom\u00e1tico) activamos el \"secado a mano\" self.lavadero.hacerLavado(False, False, False) fases = [self.lavadero.fase] while self.lavadero.ocupado: self.lavadero.avanzarFase() fases.append(self.lavadero.fase) esperado = [ Lavadero.FASE_INACTIVO, Lavadero.FASE_COBRANDO, Lavadero.FASE_ECHANDO_AGUA, Lavadero.FASE_ENJABONANDO, Lavadero.FASE_RODILLOS, Lavadero.FASE_SECADO_AUTOMATICO, Lavadero.FASE_INACTIVO, ] self.assertEqual(fases, esperado) Estas pruebas empiezan a ser un poco m\u00e1s complicadas que las anteriores, lo que estoy haciendo en este test es hacer un lavado y luego crear e\u00a1un bucle que seguira mientra el lavadero est\u00e1 ocupado, este avanzar\u00e1 las fases y las guardar\u00e1 en fases , luego hago una tupla llamada esperado que son las fases por las que deber\u00eda pasar sin ning\u00fan extra. Nos da error ya que pasa por la fase 7 en vez de por la fase 6, esto se debe a que hay un elif dentro de el m\u00e9todo para cambiar de pase que las condiciones est\u00e1n al reves. elif self.__fase == self.FASE_RODILLOS: if self.__secado_a_mano: self.__fase = self.FASE_SECADO_AUTOMATICO else: self.__fase = self.FASE_SECADO_MANO Esto se arregla facilmente dandole la vuelta a las constantes. Comprobaci\u00f3n : Prueba 10 def test10_avanzarfases_con_prelavado(self): \"\"\"Test 10: Verifica la secuencia de fases con prelavado a mano: 0,1,2,3,4,5,6,0.\"\"\" self.lavadero.hacerLavado(True, False, False) fases = [self.lavadero.fase] while self.lavadero.ocupado: self.lavadero.avanzarFase() fases.append(self.lavadero.fase) esperado = [ Lavadero.FASE_INACTIVO, Lavadero.FASE_COBRANDO, Lavadero.FASE_PRELAVADO_MANO, Lavadero.FASE_ECHANDO_AGUA, Lavadero.FASE_ENJABONANDO, Lavadero.FASE_RODILLOS, Lavadero.FASE_SECADO_AUTOMATICO, Lavadero.FASE_INACTIVO, ] self.assertEqual(fases, esperado) # Bloque de ejecuci\u00f3n para ejecutar los tests si el archivo es corrido directamente if __name__ == '__main__': unittest.main() Sigue la misma l\u00f3gica que en el 9 solo que esta vez con prelavado a mano. El c\u00f3digo pasa el test a la primera. Prueba 11 def test11_avanzarfases_con_secadoamano(self): \"\"\"Test 11: Verifica la secuencia de fases con secado a mano: 0,1,3,4,5,7,0.\"\"\" self.lavadero.hacerLavado(False, True, False) fases = [self.lavadero.fase] while self.lavadero.ocupado: self.lavadero.avanzarFase() fases.append(self.lavadero.fase) esperado = [ Lavadero.FASE_INACTIVO, Lavadero.FASE_COBRANDO, Lavadero.FASE_ECHANDO_AGUA, Lavadero.FASE_ENJABONANDO, Lavadero.FASE_RODILLOS, Lavadero.FASE_SECADO_MANO, Lavadero.FASE_INACTIVO, ] self.assertEqual(fases, esperado) Con secado a mano tambien se pasa el test a la primera. Prueba 12 def test12_avanzarfases_con_secadoamano_y_encerado(self): \"\"\"Test 12: Verifica la secuencia de fases con secado a mano y encerado: 0,1,3,4,5,7,8,0.\"\"\" self.lavadero.hacerLavado(False, True, True) fases = [self.lavadero.fase] while self.lavadero.ocupado: self.lavadero.avanzarFase() fases.append(self.lavadero.fase) esperado = [ Lavadero.FASE_INACTIVO, Lavadero.FASE_COBRANDO, Lavadero.FASE_ECHANDO_AGUA, Lavadero.FASE_ENJABONANDO, Lavadero.FASE_RODILLOS, Lavadero.FASE_SECADO_MANO, Lavadero.FASE_ENCERADO, Lavadero.FASE_INACTIVO, ] self.assertEqual(fases, esperado) Da error con secado a mano y encerado porque en el m\u00e9todo de cambiar de fase cuando llega a secado a mano este termina y no comprueba nubnca si la variable encerado est\u00e1 en true . Este ser\u00eda el arreglo. Despu\u00e9s de agregar esa condici\u00f3n if comprobamos que se completa el test. Prueba 13 def test13_avanzarfases_con_prelavado_y_secadoamano(self): \"\"\"Test 13: Verifica la secuencia de fases con prelavado a mano y secado a mano: 0,1,2,3,4,5,7,0.\"\"\" self.lavadero.hacerLavado(True, True, False) fases = [self.lavadero.fase] while self.lavadero.ocupado: self.lavadero.avanzarFase() fases.append(self.lavadero.fase) esperado = [ Lavadero.FASE_INACTIVO, Lavadero.FASE_COBRANDO, Lavadero.FASE_PRELAVADO_MANO, Lavadero.FASE_ECHANDO_AGUA, Lavadero.FASE_ENJABONANDO, Lavadero.FASE_RODILLOS, Lavadero.FASE_SECADO_MANO, Lavadero.FASE_INACTIVO, ] self.assertEqual(fases, esperado) Prelavado y secado a mano pasan el test de las fases a la primera. Prueba 14 def test14_avanzarfases_con_todas_opciones(self): \"\"\"Test 14: Verifica la secuencia de fases con todas las opciones: 0,1,2,3,4,5,7,8,0.\"\"\" self.lavadero.hacerLavado(True, True, True) fases = [self.lavadero.fase] while self.lavadero.ocupado: self.lavadero.avanzarFase() fases.append(self.lavadero.fase) esperado = [ Lavadero.FASE_INACTIVO, Lavadero.FASE_COBRANDO, Lavadero.FASE_PRELAVADO_MANO, Lavadero.FASE_ECHANDO_AGUA, Lavadero.FASE_ENJABONANDO, Lavadero.FASE_RODILLOS, Lavadero.FASE_SECADO_MANO, Lavadero.FASE_ENCERADO, Lavadero.FASE_INACTIVO, ] self.assertEqual(fases, esperado) \u00daltimo test tambi\u00e9n pasado a la primera. TODAS LAS PRUEBAS PASADAS","title":"Pruebas"},{"location":"pruebas/#pruebas-unitarias","text":"En este documento mi objetivo es realizar en c\u00f3digo de python algunas pruebas unitarias y comprobar su resultado, el esquema que seguir\u00e9 ser\u00e1 ir una por una explicando la prueba, si da error y luego explicar el c\u00f3digo solucionado con una catura de pantalla.","title":"Pruebas unitarias"},{"location":"pruebas/#prueba-1","text":"def test1_estado_inicial_correcto(self): \"\"\"Test 1: Verifica que el estado inicial es Inactivo y con 0 ingresos.\"\"\" self.assertEqual(self.lavadero.fase, Lavadero.FASE_INACTIVO) self.assertEqual(self.lavadero.ingresos, 0.0) self.assertFalse(self.lavadero.ocupado) Aqu\u00ed comprueba que los valores base son los correctos utilizando `assert. Como se puede apreciar en la imagen el test1 se pasa sin problema.","title":"Prueba 1"},{"location":"pruebas/#prueba-2","text":"def test2_excepcion_encerado_sin_secado(self): \"\"\"Test 2: Comprueba que encerar sin secado a mano lanza ValueError.\"\"\" # _hacer_lavado: (Prelavado: False, Secado a mano: False, Encerado: True) with self.assertRaises(ValueError): self.lavadero.hacerLavado(False, False, True) En este test se comprueba que cuando se va a comenzar la fase de encerar sin haber secado a mano el programa lance un ValueError (En la pr\u00e1ctica especifica otro tipo de excepci\u00f3n IllegalArgumentException pero esta al parecer no es un error de python y el que se utilza en python es ValueError), esto se comrpueba con la l\u00ednea de assertRaises la cual comprobar\u00e1 si la excepci\u00f3n es la que esperamos. Como se puede ver en la imagen , nos devuelve la excepci\u00f3n que queremos por lo tanto este test tambi\u00e9n lo pasa.","title":"Prueba 2"},{"location":"pruebas/#prueba-3","text":"def test3_excepcion_lavado_ocupado(self): \"\"\"Test 3: Verifica que intentar lavar cuando el lavadero est\u00e1 ocupado lanza IllegalStateException.\"\"\" self.lavadero.hacerLavado(True, False, False) # Inicia un lavado with self.assertRaises(IllegalStateException): self.lavadero.hacerLavado(False, True, False) # Intenta iniciar otro lavado Como en el anterior buscamos que nos salga el error que especificamos (IllegalStateException). \u00a1Vaya! Parece que esta vez no ha pasado el test nuestro c\u00f3digo, si analizamos el error vemos que nos levanta otra excepci\u00f3n , por suerte eso tiene facil soluci\u00f3n, en el m\u00e9todo de hacerLavado dentro del primer if debemos cambiar la excepci\u00f3n que levanta a IllegalStateException e importarla. Una vez arreglado y guardado nuestro c\u00f3digo, comprobamos que esta vez pasa el test.","title":"Prueba 3"},{"location":"pruebas/#prueba-4","text":"def test4_prelavadoamano_ingresos_correctos(self): \"\"\"Test 4: Verifica que el prelavado a mano a\u00f1ade 6.5 a los ingresos.\"\"\" self.lavadero.hacerLavado(True, False, False) self.lavadero._cobrar() self.assertEqual(self.lavadero.ingresos, 6.5) Este test hace una prueba de un lavado con un prelavado a mano y luego al cobrar verifica que el resultado sea 6.5. Como se puede apreciar en la imagen , se ha pasado el test a la primera y si nos fijamos en el c\u00f3digo podemos ver que el lavado tiene un precio base de 5 y el prelavado a mano a\u00f1ade 1.5, acabamos de comprobar que nuestro test funciona y que nuestro c\u00f3digo lo ha pasado.","title":"Prueba 4"},{"location":"pruebas/#prueba-5","text":"def test5_secadoamano_ingresos_correctos(self): \"\"\"Test 5: Verifica que el secado a mano a\u00f1ade 6.0 a los ingresos.\"\"\" self.lavadero.hacerLavado(False, True, False) self.lavadero._cobrar() self.assertEqual(self.lavadero.ingresos, 6.0) La l\u00f3gica es la misma que con el test 4 solo que el secado a mano deber\u00eda dar como resultado 6. Falla el test, en la variable se suman 20 ctms m\u00e1s de los que se deber\u00edan as\u00ed que cambio el valor de sumar a 1 en vez de 1.20. Y comprobamos que pasa el test.","title":"Prueba 5"},{"location":"pruebas/#prueba-6","text":"def test6_secadoamano_y_encerado_ingresos_correctos(self): \"\"\"Test 6: Verifica que el secado a mano y encerado a\u00f1aden 7.2 a los ingresos.\"\"\" self.lavadero.hacerLavado(False, True, True) self.lavadero._cobrar() self.assertEqual(self.lavadero.ingresos, 7.2) Lo mismo pero juntando secado a mano y encerado, los ingresos deber\u00edan ser 7.2 Nos da error ya que cuenta 20 ctms de menos, se arregla cambiando el valor de el encerado y subiendole 0.20. Comprobaci\u00f3n :","title":"Prueba 6"},{"location":"pruebas/#prueba-7","text":"def test7_prelavadoamano_y_secadoamano_ingresos_correctos(self): \"\"\"Test 7: Verifica que el prelavado a mano y secado a mano a\u00f1aden 7.5 a los ingresos.\"\"\" self.lavadero.hacerLavado(True, True, False) self.lavadero._cobrar() self.assertEqual(self.lavadero.ingresos, 7.5) El resultado de esta prueba deber\u00e1 ser 7.5 ya que junta prelavado a mano y secado a mano. Da el resultado correcto ya que con los test anteriores he cambiado los valores para que cuadren.","title":"Prueba 7"},{"location":"pruebas/#prueba-8","text":"def test8_todas_opciones_ingresos_correctos(self): \"\"\"Test 8: Verifica que todas las opciones a\u00f1aden 8.7 a los ingresos.\"\"\" self.lavadero.hacerLavado(True, True, True) self.lavadero._cobrar() self.assertEqual(self.lavadero.ingresos, 8.7) Este test comprueba que teniendo todas las opciones de lavado activadas de 8.70 euros de ingresos. Como en el test anterior este da la cantidad correcta porque hemos modificado las variables anteriormente.","title":"Prueba 8"},{"location":"pruebas/#prueba-9","text":"def test9_avanzarfases_sin_extras(self): \"\"\"Test 9: Verifica la secuencia de fases: 0,1,3,4,5,6,0.\"\"\" # Para alcanzar la fase 6 (secado autom\u00e1tico) activamos el \"secado a mano\" self.lavadero.hacerLavado(False, False, False) fases = [self.lavadero.fase] while self.lavadero.ocupado: self.lavadero.avanzarFase() fases.append(self.lavadero.fase) esperado = [ Lavadero.FASE_INACTIVO, Lavadero.FASE_COBRANDO, Lavadero.FASE_ECHANDO_AGUA, Lavadero.FASE_ENJABONANDO, Lavadero.FASE_RODILLOS, Lavadero.FASE_SECADO_AUTOMATICO, Lavadero.FASE_INACTIVO, ] self.assertEqual(fases, esperado) Estas pruebas empiezan a ser un poco m\u00e1s complicadas que las anteriores, lo que estoy haciendo en este test es hacer un lavado y luego crear e\u00a1un bucle que seguira mientra el lavadero est\u00e1 ocupado, este avanzar\u00e1 las fases y las guardar\u00e1 en fases , luego hago una tupla llamada esperado que son las fases por las que deber\u00eda pasar sin ning\u00fan extra. Nos da error ya que pasa por la fase 7 en vez de por la fase 6, esto se debe a que hay un elif dentro de el m\u00e9todo para cambiar de pase que las condiciones est\u00e1n al reves. elif self.__fase == self.FASE_RODILLOS: if self.__secado_a_mano: self.__fase = self.FASE_SECADO_AUTOMATICO else: self.__fase = self.FASE_SECADO_MANO Esto se arregla facilmente dandole la vuelta a las constantes. Comprobaci\u00f3n :","title":"Prueba 9"},{"location":"pruebas/#prueba-10","text":"def test10_avanzarfases_con_prelavado(self): \"\"\"Test 10: Verifica la secuencia de fases con prelavado a mano: 0,1,2,3,4,5,6,0.\"\"\" self.lavadero.hacerLavado(True, False, False) fases = [self.lavadero.fase] while self.lavadero.ocupado: self.lavadero.avanzarFase() fases.append(self.lavadero.fase) esperado = [ Lavadero.FASE_INACTIVO, Lavadero.FASE_COBRANDO, Lavadero.FASE_PRELAVADO_MANO, Lavadero.FASE_ECHANDO_AGUA, Lavadero.FASE_ENJABONANDO, Lavadero.FASE_RODILLOS, Lavadero.FASE_SECADO_AUTOMATICO, Lavadero.FASE_INACTIVO, ] self.assertEqual(fases, esperado) # Bloque de ejecuci\u00f3n para ejecutar los tests si el archivo es corrido directamente if __name__ == '__main__': unittest.main() Sigue la misma l\u00f3gica que en el 9 solo que esta vez con prelavado a mano. El c\u00f3digo pasa el test a la primera.","title":"Prueba 10"},{"location":"pruebas/#prueba-11","text":"def test11_avanzarfases_con_secadoamano(self): \"\"\"Test 11: Verifica la secuencia de fases con secado a mano: 0,1,3,4,5,7,0.\"\"\" self.lavadero.hacerLavado(False, True, False) fases = [self.lavadero.fase] while self.lavadero.ocupado: self.lavadero.avanzarFase() fases.append(self.lavadero.fase) esperado = [ Lavadero.FASE_INACTIVO, Lavadero.FASE_COBRANDO, Lavadero.FASE_ECHANDO_AGUA, Lavadero.FASE_ENJABONANDO, Lavadero.FASE_RODILLOS, Lavadero.FASE_SECADO_MANO, Lavadero.FASE_INACTIVO, ] self.assertEqual(fases, esperado) Con secado a mano tambien se pasa el test a la primera.","title":"Prueba 11"},{"location":"pruebas/#prueba-12","text":"def test12_avanzarfases_con_secadoamano_y_encerado(self): \"\"\"Test 12: Verifica la secuencia de fases con secado a mano y encerado: 0,1,3,4,5,7,8,0.\"\"\" self.lavadero.hacerLavado(False, True, True) fases = [self.lavadero.fase] while self.lavadero.ocupado: self.lavadero.avanzarFase() fases.append(self.lavadero.fase) esperado = [ Lavadero.FASE_INACTIVO, Lavadero.FASE_COBRANDO, Lavadero.FASE_ECHANDO_AGUA, Lavadero.FASE_ENJABONANDO, Lavadero.FASE_RODILLOS, Lavadero.FASE_SECADO_MANO, Lavadero.FASE_ENCERADO, Lavadero.FASE_INACTIVO, ] self.assertEqual(fases, esperado) Da error con secado a mano y encerado porque en el m\u00e9todo de cambiar de fase cuando llega a secado a mano este termina y no comprueba nubnca si la variable encerado est\u00e1 en true . Este ser\u00eda el arreglo. Despu\u00e9s de agregar esa condici\u00f3n if comprobamos que se completa el test.","title":"Prueba 12"},{"location":"pruebas/#prueba-13","text":"def test13_avanzarfases_con_prelavado_y_secadoamano(self): \"\"\"Test 13: Verifica la secuencia de fases con prelavado a mano y secado a mano: 0,1,2,3,4,5,7,0.\"\"\" self.lavadero.hacerLavado(True, True, False) fases = [self.lavadero.fase] while self.lavadero.ocupado: self.lavadero.avanzarFase() fases.append(self.lavadero.fase) esperado = [ Lavadero.FASE_INACTIVO, Lavadero.FASE_COBRANDO, Lavadero.FASE_PRELAVADO_MANO, Lavadero.FASE_ECHANDO_AGUA, Lavadero.FASE_ENJABONANDO, Lavadero.FASE_RODILLOS, Lavadero.FASE_SECADO_MANO, Lavadero.FASE_INACTIVO, ] self.assertEqual(fases, esperado) Prelavado y secado a mano pasan el test de las fases a la primera.","title":"Prueba 13"},{"location":"pruebas/#prueba-14","text":"def test14_avanzarfases_con_todas_opciones(self): \"\"\"Test 14: Verifica la secuencia de fases con todas las opciones: 0,1,2,3,4,5,7,8,0.\"\"\" self.lavadero.hacerLavado(True, True, True) fases = [self.lavadero.fase] while self.lavadero.ocupado: self.lavadero.avanzarFase() fases.append(self.lavadero.fase) esperado = [ Lavadero.FASE_INACTIVO, Lavadero.FASE_COBRANDO, Lavadero.FASE_PRELAVADO_MANO, Lavadero.FASE_ECHANDO_AGUA, Lavadero.FASE_ENJABONANDO, Lavadero.FASE_RODILLOS, Lavadero.FASE_SECADO_MANO, Lavadero.FASE_ENCERADO, Lavadero.FASE_INACTIVO, ] self.assertEqual(fases, esperado) \u00daltimo test tambi\u00e9n pasado a la primera.","title":"Prueba 14"},{"location":"pruebas/#todas-las-pruebas-pasadas","text":"","title":"TODAS LAS PRUEBAS PASADAS"},{"location":"reflexion/","text":"REFLEXI\u00d3N SOBRE LOS LENGUAJES DE PROGRAMACI\u00d3N DE HECTORBG Me siento m\u00e1s comodo si enfoco mi reflexi\u00f3n a los distintos tipos de lenguaje de programaci\u00f3n , en concreto enfrentandolos entre si , es decir en base a los tipos que est\u00e1n dispuestos en los contenidos teoricos de la unidad. Alto Nivel vs Bajo Nivel Desde mi punto de vista lo de alto nivel tienen una ventaja clara en lo que se refiere a seguridad, debido a que son m\u00e1s cercanos a nosotros, los entendemos mejor y nos cuesta menos realizar programas m\u00e1s complejos. Esto se traduce directamente a que es tarea m\u00e1s sencilla indentificar errores y vulnerabilidades para corregirlos o desarrollar metodos y herramientas para prevenirlos(como es el caso de try catch en java) en comparaci\u00f3n a lenguajes de bajo nivel que son m\u00e1s r\u00e1pidos en ejecuci\u00f3n pero muy complicados a la hora de desarrollar (como lenguaje ensamblador). Compilados vs Interpretados En este caso opino que los lenguajes compilados (como C o C++) tambi\u00e9n tienen una ventaja sobre todo en la solventaci\u00f3n de errores, ya que estos tienen el paso intermedio de la compilaci\u00f3n se pueden corregir errores de sintaxis y volver el c\u00f3digo m\u00e1s robusto antes de la primera ejecucci\u00f3n mientras que los copilados (Python o JavaScript) son m\u00e1s r\u00e1pidos en el ciclo de desarrollo pero tambien m\u00e1s propensos a tener fallos de sintaxis. Hibridos En mi novata opini\u00f3n y en la teor\u00eda parece ser que los hibridos son los m\u00e1s seguros en general , por ejemplo la estrategia de Java es copilar un lenguaje intermedio y luego mediante una m\u00e1quina virtual lo interpreta lo que como ya he dicho lo vuelve muy seguro pero tambien demasiado costoso de ejecutar ya que siempre tienes que tener una m\u00e1quina virtual activa.","title":"Reflexi\u00f3n personal"},{"location":"reflexion/#reflexion-sobre-los-lenguajes-de-programacion-de-hectorbg","text":"Me siento m\u00e1s comodo si enfoco mi reflexi\u00f3n a los distintos tipos de lenguaje de programaci\u00f3n , en concreto enfrentandolos entre si , es decir en base a los tipos que est\u00e1n dispuestos en los contenidos teoricos de la unidad.","title":"REFLEXI\u00d3N SOBRE LOS LENGUAJES DE PROGRAMACI\u00d3N DE HECTORBG"},{"location":"reflexion/#alto-nivel-vs-bajo-nivel","text":"Desde mi punto de vista lo de alto nivel tienen una ventaja clara en lo que se refiere a seguridad, debido a que son m\u00e1s cercanos a nosotros, los entendemos mejor y nos cuesta menos realizar programas m\u00e1s complejos. Esto se traduce directamente a que es tarea m\u00e1s sencilla indentificar errores y vulnerabilidades para corregirlos o desarrollar metodos y herramientas para prevenirlos(como es el caso de try catch en java) en comparaci\u00f3n a lenguajes de bajo nivel que son m\u00e1s r\u00e1pidos en ejecuci\u00f3n pero muy complicados a la hora de desarrollar (como lenguaje ensamblador).","title":"Alto Nivel vs Bajo Nivel"},{"location":"reflexion/#compilados-vs-interpretados","text":"En este caso opino que los lenguajes compilados (como C o C++) tambi\u00e9n tienen una ventaja sobre todo en la solventaci\u00f3n de errores, ya que estos tienen el paso intermedio de la compilaci\u00f3n se pueden corregir errores de sintaxis y volver el c\u00f3digo m\u00e1s robusto antes de la primera ejecucci\u00f3n mientras que los copilados (Python o JavaScript) son m\u00e1s r\u00e1pidos en el ciclo de desarrollo pero tambien m\u00e1s propensos a tener fallos de sintaxis.","title":"Compilados vs Interpretados"},{"location":"reflexion/#hibridos","text":"En mi novata opini\u00f3n y en la teor\u00eda parece ser que los hibridos son los m\u00e1s seguros en general , por ejemplo la estrategia de Java es copilar un lenguaje intermedio y luego mediante una m\u00e1quina virtual lo interpreta lo que como ya he dicho lo vuelve muy seguro pero tambien demasiado costoso de ejecutar ya que siempre tienes que tener una m\u00e1quina virtual activa.","title":"Hibridos"},{"location":"sandbox/","text":"CREACI\u00d3N DE ENTORNO SEGURO Empezamos descargando el paquete de firetools si no lo tenemos isntalado ya en kali. sudo apt update && sudo apt install firetools Luego continuamos abriendo firejail y dentro de el podemos observar que se puede a\u00f1adir una aplicaci\u00f3n, sabiendo esto podemos abrir desde el men\u00fa una terminal de administrador, hacer click derecho encima y darle a \"editar\" entonces ah\u00ed podremos ver la orden de ejecuci\u00f3n. Una vez copiado y pegado en la barra inferior podemos guardar la configuraci\u00f3n y cuando queramos abrir la terminal como root se nos abrir\u00e1 el entorno seguro (Se puede verificar porque al ejecutar el comando mount vemos que hay archivos temporales). Y ahora solo nos hace falta comprobar si tenemos instalado python , meternos en la carpeta del proyecto y ejecutar el entorno virtual de python para tenerlo todo listo. Para acabar ejecutamos nuestra aplicaci\u00f3n en el entorno seguro que acabamos de crear.","title":"Sandbox"},{"location":"sandbox/#creacion-de-entorno-seguro","text":"Empezamos descargando el paquete de firetools si no lo tenemos isntalado ya en kali. sudo apt update && sudo apt install firetools Luego continuamos abriendo firejail y dentro de el podemos observar que se puede a\u00f1adir una aplicaci\u00f3n, sabiendo esto podemos abrir desde el men\u00fa una terminal de administrador, hacer click derecho encima y darle a \"editar\" entonces ah\u00ed podremos ver la orden de ejecuci\u00f3n. Una vez copiado y pegado en la barra inferior podemos guardar la configuraci\u00f3n y cuando queramos abrir la terminal como root se nos abrir\u00e1 el entorno seguro (Se puede verificar porque al ejecutar el comando mount vemos que hay archivos temporales). Y ahora solo nos hace falta comprobar si tenemos instalado python , meternos en la carpeta del proyecto y ejecutar el entorno virtual de python para tenerlo todo listo. Para acabar ejecutamos nuestra aplicaci\u00f3n en el entorno seguro que acabamos de crear.","title":"CREACI\u00d3N DE ENTORNO SEGURO"}]}